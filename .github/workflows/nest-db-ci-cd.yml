name: Reusable NestJS + DB CI/CD

on:
  workflow_call:
    inputs:
      service-name:
        required: true
        type: string
      docker-image-name:
        required: true
        type: string
      service-port:
        required: true
        type: string
      sonar-project-key:
        required: true
        type: string
      node-version:
        required: false
        type: string
        default: '20'
    secrets:
      # Credenciales Infra
      SONAR_TOKEN:
        required: true
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true
      VPS_HOST:
        required: true
      VPS_USERNAME:
        required: true
      VPS_PRIVATE_KEY:
        required: true
      
      # Variables de Entorno del Proyecto (DB, Redis, etc)
      DB_HOST:
        required: true
      DB_PORT:
        required: true
      DB_NAME:
        required: true
      DB_USER:
        required: true
      DB_PASSWORD:
        required: true
      REDIS_HOST:
        required: true
      REDIS_PORT:
        required: true
      # Opcionales para JWT/API Keys si aplican
      JWT_SECRET:
        required: false
      API_KEY:
        required: false

jobs:
  analyze:
    name: Build & Analyze
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para SonarCloud

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}

      - name: Install pnpm
        run: corepack enable && corepack prepare pnpm@latest --activate

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint & Build Check
        run: |
          pnpm run lint
          pnpm run build

      - name: Run Unit Tests
        run: pnpm run test
        # Nota: Si quisieras correr test e2e aquÃ­, necesitarÃ­as levantar servicios de postgres/redis
        # usando la propiedad `services` de GitHub Actions.

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.projectKey=${{ inputs.sonar-project-key }}
            -Dsonar.organization=my-banking-app
            -Dsonar.sources=src
            -Dsonar.tests=test
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: analyze
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push production image
        run: |
          docker buildx build --push \
            --tag ${{ secrets.DOCKER_USERNAME }}/${{ inputs.docker-image-name }}:latest \
            --tag ${{ secrets.DOCKER_USERNAME }}/${{ inputs.docker-image-name }}:${{ github.sha }} .

      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_PRIVATE_KEY }}
          script: |
            echo "ðŸš€ Deploying ${{ inputs.service-name }}..."
            
            # Login remoto (opcional si el repo es pÃºblico, recomendado si es privado)
            echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
            
            # Pull de la nueva imagen
            docker pull ${{ secrets.DOCKER_USERNAME }}/${{ inputs.docker-image-name }}:latest
            
            # Detener y remover contenedor anterior
            docker stop ${{ inputs.docker-image-name }} || true
            docker rm ${{ inputs.docker-image-name }} || true
            
            # Correr nuevo contenedor conectÃ¡ndolo a la red 'banking-net' (o la que uses en el VPS)
            # Inyectamos las variables de DB y Redis
            docker run -d \
              --name ${{ inputs.docker-image-name }} \
              --restart unless-stopped \
              --network banking-net \
              -p ${{ inputs.service-port }}:${{ inputs.service-port }} \
              -e NODE_ENV=production \
              -e PORT=${{ inputs.service-port }} \
              -e DB_HOST=${{ secrets.DB_HOST }} \
              -e DB_PORT=${{ secrets.DB_PORT }} \
              -e DB_NAME=${{ secrets.DB_NAME }} \
              -e DB_USER=${{ secrets.DB_USER }} \
              -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
              -e REDIS_HOST=${{ secrets.REDIS_HOST }} \
              -e REDIS_PORT=${{ secrets.REDIS_PORT }} \
              -e JWT_SECRET=${{ secrets.JWT_SECRET }} \
              ${{ secrets.DOCKER_USERNAME }}/${{ inputs.docker-image-name }}:latest
            
            # Limpieza de imÃ¡genes viejas
            docker image prune -f
            
            echo "âœ… ${{ inputs.service-name }} deployed successfully!"